# Results:

## Clustering of samples shows distinct kinases, and condition, and pathway specific groups

### Clustering with TSNE

There are 300 samples, each with an applied condition, kinase inhibition, and a gene expression vector. Here, we cluster the samples by performing t-SNE on gene expression vectors with default t-SNE parameters

```{r ref.label='tsne_cluster', eval=FALSE}
```


When plotting the gene expression vectors in t-SNE space, we see that the samples cluster into distinct kinase, and condition, and context dependent clusters:

```{r, message = FALSE, fig.width=12, fig.height=10}
library(ggrepel)
select = dplyr::select
tsne_plot = function(df){
ggplot(df,
       aes(x=TSNE1,
           y=TSNE2,
           color = Condition,
           label = Strain_Code)) +
  geom_point(size=4) +
  geom_text_repel(size = 2,
                  color = 'black',
                  point.padding = NA,
                  box.padding = unit(0.01, "lines"))
}
tsne_plot(sample_tsne %>% filter(grepl('WT', Strain_Code))) + ggtitle('just WT')
tsne_plot(sample_tsne)
```

### Full dataset heatmap

Using these groups, we order the samples in terms of their cluster, and show the full heatmap.

TODO: Define tsne clusters, and then show the clusters in a morpheous image

Currently, we just show the data ordered by Stress, or Kinase


```{r}
genes %>% 
  dplyr::select(name, data) %>% 
  unnest() %>% 
  dplyr::select(Norm_Differential_Expression, Sample_Name, name) %>% 
  spread(key = Sample_Name, value = Norm_Differential_Expression, fill = NA) %>%
  remove_rownames() %>% 
  column_to_rownames('name') %>% 
  as.matrix() -> gene_expression_matrix

# meta = as_tibble(meta)
as_tibble(meta) %>%
     dplyr::slice(match(colnames(gene_expression_matrix), Sample_Name)) %>%
     dplyr::select(Condition, Strain) -> meta_sub
strain_color = rainbow(29)[factor(meta_sub$Strain)]
condition_color = rainbow(10)[factor(meta_sub$Condition)]
ColSideColors = cbind(Condition=condition_color, Strain=strain_color)

num_genes_to_show = 5000

genes %>% 
  filter(Gene_mean > 6) %>% 
  top_n(num_genes_to_show, Gene_sd) %>% 
  pull(name) -> genes_to_show


library(heatmap3)

heatmap3(gene_expression_matrix[genes_to_show,],
ColSideColors=ColSideColors,
showRowDendro=FALSE,
scale = 'none',
balanceColor = TRUE,
labRow = NA,
labCol = NA
)

```


##### Ordered by condition:

![](img/by_condition.png)

\newpage

##### Ordered by kinase:

![](img/by_strain.png)

\newpage



## A strategy to explore Kinome wide signaling under stress

Kinases are largely responsible for mediating environmental information to the nucleus where an adaptive transcriptional response can be made.
The propagation of this information occurs through a pathways of cascading phosphorylation events.
Here we use strains with analog sensitive mutants of certain stress associated kinases to block kinase signaling while under a variety of stress.
The resulting change in gene expression is then measured using RNA-seq and analyzed.

From this data we hope to characterize three sets of attributes for each gene.
1. The general effect a condition has on the genes
2. The general effect the inhibition of a kinase has on the gene.
3. specific instancs of condition + kinase-inhibition pairs that do not conform to the addition of their general effects

To atchieve this we create a linear model for each gene, using the `Condition` and `Kinase` as predictor variables to predict `Expression` as an output variable (The intercept is also included as a predictor varible).
As linear models require a reference level for each predictor factor, The baseline `Kinase` is the wildtype strain and the base condition is YPD.
The linear model has the form `Expression ~ Kinase + Condition + Intercept`.

The interpretation of the weights in a linear model are as follows.

The intercept indicates the best approximation to the gene expression for wildtype cells in YPD
The Condition weight indicates the best apprroxiation to the change that a non-YPD condition will have on a gene. (over all kinases)
The Kinase weight indicates the best approximatiun to the change caused by inhibiting a given kinase (over all conditions)

NOTE: I could just use WT-condition and YPD-kinase here. It would be easier to explain, however it would also not have the statistical power that we are using with all 300 data points. especially for the kinase sets.

```{r ref.label='creat_linear_models', eval=FALSE}
```
From these models, we extract weights to address attribute 1 and 2, and residuals for attribute 3. Investigation of these values follow in downstream analysis.

Model performace is also assesed to see if a simplistic additive linear (with no interaction term) is capable of modeling the majority of the signal. turns out it does pretty well, see supplement for an indepth analysis.

## Condition weights identify generally accepted gene expression responses

How am i going to show this? is it important?

## Kinase inhibition indicates kinase activity in reference Condition

Basically. I want to start to introduce the logic behind kinase inhibition. If the kinase is off in YPD, we do not expect there to be a signficiant gene exprssion response when we inhibit it. I think one thing we can make a strong claim about is how does a condition modulate a kinase. we have all the info. first we start with the basal level here. then later we use the residual to define context depent stuff.


## Error's in simple linear model reveal conetext dependent regulation.
## Gene error modules suggest context dependent regulation. Recovering known crosstalk and uncovering potential new context dependent regulation.


```{r, message=FALSE, warning=FALSE}
library(plotly)
```

### Calculation of standard residuals

When using a linear regression model to account for generalizable effects, residuals identify context dependenet regulation pathways

We identify this for genes (supplement) and expand it to modules (in main text)

We will calculate the standardized residuals for each measurement, where standardized residuals are defined as

$$ S_g = \frac{E_g - \hat{E_g}}{\overline{E_g}} $$

```{r ref.label='extract_residuals', eval = FALSE}
```

Now that we have the standardized residuals, lets take a look at them. What structure do they have? lets take a deep dive.

First question, what is the spread of these standardized residuals, according to theory, they should look similar to a z-score, meaning that they are normally distributed. lets check:

```{r}
resids = std_residuals  %>% pull(residual)
hist(resids, breaks = 200)
```

Okay, that looks good, but what are the mean and variance? we expect 0, and 1.

```{r}
print(paste('Mean:', mean(resids)))
print(paste('Standard Deviation:', sd(resids)))

```

Close enough!

### Using residual size to predict epistasis

We extract measurements that have the largest residuals, and look at the experimental conditions that produced them. lets take a look at the top ones:

```{r, warning=FALSE, message=FALSE}
std_residuals %>%
  arrange(-abs(residual)) %>%
  left_join(t2g %>% select(Gene, name, description)) %>%
  separate(sample_id,c('Strain_Code','Condition'), sep='_') -> hypotheses

knitr::kable(hypotheses[1:15,], caption = 'The most significant residuals')
```

This table is available as a supplemental table saved here:

```{r}
write.csv(hypotheses, file = 'hypotheses.csv')
```

Next, lets see what `Condition + Strain` pairs contain significant residuals over all genes in the ESR:

```{r}
hypotheses %>%
  filter(abs(residual) > 3) %>%
  filter(Gene %in% c(scan('../../input/genes_of_interest_and_gene_sets/ESR/repressed_ESR.txt', what = character()),
                     scan('../../input/genes_of_interest_and_gene_sets/ESR/activated_ESR.txt', what = character()))) %>%
  select(Condition, Strain_Code) %>%
  table() %>%
  `+`(1) %>%
  log() %>%
  heatmap(col=viridis::viridis(20))

```

#### Some quick observations here:
* Kinases in the same pathway cluster together:
    + SLT2 and PKC are very closely clustered!
    + PBS2 and HOG1 are very closely clustered!
* SCH9 Seems to have an effect, but only in YPD?

#### Diving into a some examples

Okay, so if the findings above are true, we should see that the residuals between PBS2, and HOG1 to correlate for genes that have significant residuals. lets check that now:

```{r, warning=FALSE}
p = hypotheses %>%
    filter(abs(residual) > 3) %>%
    filter(Strain_Code %in% c('HOG1', 'PBS2')) %>%
  select(name, residual, Strain_Code, Condition) %>%
  spread(Strain_Code, residual) %>%
  mutate_at(3:4, function(x) if_else(is.na(x),0,x)) %>%
  ggplot(aes(x=HOG1,y=PBS2,fill=Condition,color = Condition, text= paste(name, Condition, sep='_'))) + geom_point()
plotly::ggplotly(p, width = 880)
```

Interestingly, inactivation of PBS2, and HOG1 do not always produce the correlated residuals. They do for Salt, but do not for Menadione, and Glucose Dropout. This might be evidence that PBS2 and HOG1 have different functions in non-salt conditions.



#### Expanding single gene analysis to gene modules

Here we build up residual patterns from a single gene to a module.

As an example, we are going to look into the mating pathway. The mating pathway shares a kinase with the HOG pathway (STE11). It is known that mating pathway genes are not expressed during salt stress, and that their repression is due to the activity of the HOG pathway.

We see this phenomenon in our data:


```{r}
hypotheses %>%
  filter(name == 'FUS1') %>%
  select(Strain_Code, Condition, residual) %>%
  group_by(Strain_Code, Condition) %>%
  summarise_all(mean) %>%
  ggplot(aes(x = Strain_Code, y= Condition, fill = residual)) + geom_tile() + scale_fill_gradient2(low = ('cyan'), mid = 'black', high = 'yellow') + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ggtitle('FUS1')

hypotheses %>%
  filter(name == 'AGA1') %>%
  select(Strain_Code, Condition, residual) %>%
  group_by(Strain_Code, Condition) %>%
  summarise_all(mean) %>%
  ggplot(aes(x = Strain_Code, y= Condition, fill = residual)) + geom_tile() + scale_fill_gradient2(low = ('cyan'), mid = 'black', high = 'yellow') + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ggtitle('AGA1')

```


Although we do not have replicates of these residuals, we can become more confident in our prediction if we see a similar pattern in the whole mating pathway.

To define a pathway, we use INSPIRE to cluster genes using other datatsets.

These clusters were actually generated from orthogonal data (gasch, and pronk datasets)
NB: for this data I actually also include my data... need to fix

I happen to know that FUS1 cluster is cluster 36 in this dataset, which I hope will exhibit the same residual pattern (activated in Salt, when PBS2, or HOG1 are inactive)

```{r, eval=F}
clusters_inspire = read.csv('../../input/clusters/INSPIRE_clusters/all_clusters.csv')
want = clusters_inspire %>% filter(Cluster==36) %>% select(Gene)
hypotheses %>%
  filter(Gene %in% want$Gene) %>%
  select(Strain_Code, Condition, residual) %>%
  group_by(Strain_Code, Condition) %>%
  summarise_all(mean) %>%
  ggplot(aes(x = Strain_Code, y= Condition, fill = residual)) + geom_tile() + scale_fill_gradient2(low = ('cyan'), mid = 'black', high = 'yellow') + theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

And it does. Although we do not have replicates for FUS1, if we average the residuals for the __module__ where FUS1 was included we get a robust residual pattern.


Lets see if there are meaningful go terms and motifs for this cluster:

```{r}
#knitr::kable(this_cluster)
# webshot::webshot("../../intermediate/INSPIRE_clusters/cluster_36/ame.html")
```

And what about GO terms?

```{r, warning=FALSE, message=FALSE, eval=FALSE, echo=TRUE}
get_go_terms_from_list = function(query_list, background_list) {
    library(goseq)
    library(org.Sc.sgd.db)
    genes = numeric(length(background_list))
    names(genes) = background_list
    genes[query_list] = 1
    pwf = nullp(genes,"sacCer2","ensGene")
    GO.wall=goseq(pwf,gene2cat=as.list(org.Sc.sgdGO2ALLORFS))
    return(GO.wall)
}

print_out_terms = function(g_dir){
  library(knitr)
  g_dir %>%
    dplyr::mutate(pval = min(over_represented_pvalue, under_represented_pvalue),
                  percent_in = numDEInCat / numInCat) %>%
    dplyr::arrange(pval) %>%
    dplyr::filter(pval<0.001) %>%
    dplyr::select(term, pval, percent_in) %>%
    arrange(-percent_in, pval) %>%
    head() %>% kable()
}

g = get_go_terms_from_list(clusters_inspire %>% filter(Cluster == 36) %>% pull(Gene),
                       t2g$Gene)
print_out_terms(g)
```



<!-- ### Error modules (groups of error profiles) reveal Known classes of epistatic relationships -->
<!-- <!-- Class 1 -->
<!-- The linear model assumes that Kinase identity and Condition identity make independent contributions to gene expression.   -->

<!-- 1. If a Condition's effect propagates through a inhibition given Kinase, then the linear model will overestimate gene expression for that Condition-Kinase pair   -->
<!--     * HSP12 on Salt + PKA (Get GD?) -->
<!-- 2. If a Kinase's activity is required to correctly regulate a gene's expression in a condition specific manner, the linear model will badly estimate that condition specific interaction (as there is no term to correct for such a fine tuned response) -->
<!-- 	  * Mating pathway   -->

\newpage

## Pbs2 is independently required for activation of (a submodule of) the ESR under stress.

### Claim 1: PBS2 is required for proper activation of GSR

#### Other Evidence
RNA-seq Evidence: Lower GSR (PC1) Expression in stress with PBS2 strain

```{r}
ggplot(sample_tsne, aes(x = PC1, y = PC2, color = Strain_Code=='PBS2')) + geom_point() + facet_wrap(~Condition)
```

#### Idea:
Measure ESR activity while removing PBS2

#### Experiment:
MSN2 Localization in YPD, and glucose dropout with and without PBS2
HSP12 Expression in YPD, and Glucose dropout with and without PBS2

#### Expect to see:
Activity go down with PBS2 delete

### Claim 2: PBS2 acts at, or upstream of PKA

#### Idea:
If upstream: Direct modulation of PKA activity should rescue the PBS2 phenotype.

#### Experiment:
MSN2 Localization with direct PKA inhibition with and without PBS2
HSP12 Expression with direct PKA inhibition with and without PBS2

#### Expect to see:
Direct PKA inhibition to produce same levels of activity, regardless of PBS2 state

#### Results:
![](img/hsp12_basal_nmpp1_gd.jpg)

### Claim 3: PBS2 acts at or above RAS

#### Idea:
Does direct modulation of RAS activity rescue the PBS2 phenotype? If so, the effect of PBS2 must be upstream of, or at the level of RAS. If not, PBS2 must act somewhere downstream of RAS.

#### Experiment:
Measure HSP12 activity with RAS held in the active (PKA on, MSN2 cytoplasmic, HSP12 off) followed by PBS2 activation

#### Expect to see:
MSN2 becomes less nuclear (more cytoplasmic) after PBS2 is inactivated. (This requires that the PBS2-as has normal function in the absence of 1-NMPP1)

#### Result:

![](img/salt_exp.jpg)

### Claim 4: PBS2 has a secondary function to Hog1

#### Idea:
PBS2 has a role that is HOG1 independent. this is motivated by differences in gene expression:

```{r}
sample_tsne %>% mutate(strain_of_interest = ifelse(Strain_Code %in% c('HOG1', 'PBS2'), Strain_Code, 'Other')) %>%
ggplot(aes(x = PC1, y = PC2, color = strain_of_interest)) + geom_point() + facet_wrap(~Condition)
```


#### Experiment:
Measure HSP12 activity with a dose response of PKA-as inactivation  with either WT, $\Delta$PBS2, or $\Delta$HOG1

#### Expect to see:
PBS2 to have a differnet effect to HOG1, which should look more like WT.

#### Result:
![](img/dose_curve.jpg)
![](img/ec50.jpg)
![](img/hill.jpg)
