---
title: "Data Processing"
output: html_notebook
---


This notebook takes us from the DESeq2 normalized data, to all the data that is used for plotting in the paper.

```{r data_loading}

rm(list=ls())

load('../../intermediate/images/normalized_data.RData')

library(tidyr)
library(purrr)
library(dplyr)
library(broom)
library(tibble)
library(magrittr)

measurements = vlog %>%
  as.data.frame %>%
  rownames_to_column("Gene") %>%
  as_tibble %>%
  gather(Sample_Name, Expression, -Gene)

rm(vlog)

meta = as_tibble(meta)

colnames(t2g)[1] = 'Gene'
t2g = as_tibble(t2g)

# should be a left join on the meta subsetted
meta_sub = meta %>% select(Sample_Name, Condition, Strain, Strain_Code)

measurements = left_join(measurements, meta_sub)

# Remove known bad sample

measurements %<>% filter(Strain_Code != 'WT1' | Condition != 'Rapamycin')

```

Next lets calculate some base statistics and define outliers:

```{r gene_statistics}

is_outlier <- function(v, coef=1.5){
  quantiles <- quantile(v,probs=c(0.25,0.75))
  IQR <- quantiles[2]-quantiles[1]
  res <- v < (quantiles[1]-coef*IQR)|v > (quantiles[2]+coef*IQR)
  return(res)
}


measurements = measurements %>% group_by(Gene, Condition) %>%
                mutate(is_condition_outlier = is_outlier(Expression),
                       condition_outlier = ifelse(is_condition_outlier,
                                                  as.character(Strain),
                                                  NA)) %>%
                ungroup() %>%
              group_by(Gene, Strain) %>%
                mutate(is_strain_outlier = is_outlier(Expression),
                       strain_outlier = ifelse(is_strain_outlier,
                                               as.character(Condition),
                                               NA)) %>%
                ungroup()

genes = measurements %>%
  group_by(Gene) %>%
  mutate(Differential_Expression = Expression - mean(Expression),
         Norm_Differential_Expression = Differential_Expression / sd(Expression)) %>%
  nest() %>%
  mutate(Gene_range = map_dbl(data, ~ diff(range(.$Expression))),
         Gene_sd = map_dbl(data, ~ sd(.$Expression)),
         Gene_mean = map_dbl(data, ~ mean(.$Expression))) %>%
  left_join(t2g)


```

create the linear model and extract model data:

```{r create_linear_models}

genes %<>%
  mutate(model = map(data, ~lm(Expression ~ Strain + Condition, data = .))) %>%
  mutate_at(.vars = vars(model),
            .funs = funs(performance = map(.,glance),
                         weights = map(.,tidy),
                         data_augment = map(.,augment)))

```

lets look at model performance, and figure out where our model breaks:

```{r model_performance}
library(ggplot2)
genes %>%
  select(Gene_mean, performance) %>%
  unnest() %>%
ggplot(aes(x=Gene_mean, y = r.squared)) +
  geom_point() +
  geom_vline(xintercept = 6) # TODO change this all to 5.5
```

It seems $R^2$ looks pretty bad when gene mean is below 5.5, probably becuase these genes are dominated by noise. lets therefore filter them out, and be save by filtering at 6:

```{r gene_filter}
genes %<>%
  filter(Gene_mean > 6) #TODO change this to 5.5 used to be mean > 6 to get all the good linear models. 3.6 seems good when looking at sd vs mean
```



Next lets do some basic clustering on the Differential Expression:

```{r tsne_cluster}
library(tsne)

do_tsne = function(mat){

  mat_meta = tibble(sample = colnames(mat)) %>%
    separate(sample, c('Condition', 'Strain_Code'), "_", remove = FALSE)

  pca = prcomp(t(mat))
  pca = data.frame(pca$x, sample = rownames(pca$x))
  meta_pc = full_join(mat_meta, pca)
  t = tsne(meta_pc %>% select(starts_with('PC')))
  colnames(t) = c('TSNE1', 'TSNE2')
  meta_pc = cbind(meta_pc, t)
  return(meta_pc)
}

gene_matrix = genes %>%
                unnest(data) %>%
                select(Gene, Condition, Strain_Code, Differential_Expression) %>%
                unite(sample, c(Condition, Strain_Code), remove = TRUE) %>%
                ungroup() %>%
                spread(sample, Differential_Expression)

sample_tsne = do_tsne(gene_matrix %>% select(-Gene))

```



Now lets extract the residuals for each gene model into it's own row in a wide matrix

```{r extract_residuals}
std_residuals = genes %>%
  select(data, data_augment, name) %>%
  unnest() %>%
  select(name, Condition, Strain_Code, .std.resid) %>%
  unite(sample_id, c(Strain_Code, Condition)) %>%
  rename(residual = .std.resid)

std_resid_matrix = std_residuals %>%
                     spread(key = sample_id,
                            value=residual,
                            drop = TRUE) %>%
                     remove_rownames() %>%
                     column_to_rownames(var = 'name') %>%
                     as.matrix()


```

Lets sort the genes into clusters by clustering on significantly large residuals: TODO decide if we should also include the weights as additional columns to cluster on?

Also, since small residuals are not significant, we will reduce any residual smaller than +/-2 to zero
```{r}
library(WGCNA)
resid = t(std_resid_matrix)
resid[abs(resid)<2] = 0

sampleTree = hclust(dist(resid), method = "average");
sizeGrWindow(12,9)
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree,
     main = "Sample clustering to detect outliers",
     sub="",
     xlab="",
     cex.lab = 1.5,
     cex.axis = 1.5,
     cex.main = 2)

cutoff_height = 160
abline(h = cutoff_height, col = "red");
```

WGCNA tutorial suggests that we remove the two samples with very large distance... not sure how great of an idea that is.

```{r}
clust = cutreeStatic(sampleTree,
                     cutHeight =
                       cutoff_height,
                     minSize = 10)

keepSamples = (clust==1)
resid = resid[keepSamples, ]
nGenes = ncol(resid)
nSamples = nrow(resid)


sampleTree = hclust(dist(resid), method = "average");
sizeGrWindow(12,9)
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree,
     main = "Sample clustering with outliers removed",
     sub="",
     xlab="",
     cex.lab = 1.5,
     cex.axis = 1.5,
     cex.main = 2)
```

Now its time to do the clustering. since we care about seperating negativly corrolated modules, we will use a signed network.

```{r}
collectGarbage()
enableWGCNAThreads()

network_type = 'signed'
powers = c(1:40)

sft = pickSoftThreshold(resid,
                        powerVector = powers,
                        verbose = 5,
                        # corFnc = bicor,
                        # corOptions = list(maxPOutliers = 0.05),
                        networkType = network_type)

sft_table = sft$fitIndices

plot(sft_table$median.k.,
     -sign(sft_table$slope) * sft_table$SFT.R.sq,
     xlab="Soft Threshold (power)",
     ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft_table$median.k.,
     -sign(sft_table$slope) * sft_table$SFT.R.sq,
     labels=powers,
     col="red");


net = blockwiseModules(resid,
                       power = sft$powerEstimate, # is 6 for my data
                       networType = network_type,
                       minModuleSize = 4,
                       deepSplit = 2, # 4 is very strong, 2 gets the job done. not sure about 3
                       maxBlockSize = 30000,
                       numericLabels = TRUE,
                       pamRespectsDendro = FALSE,
                       verbose = 3)

```

```{r}
moduleLabels = net$colors
moduleColors = labels2colors(moduleLabels)

modules = tibble(module = as.character(moduleLabels),
                 name = colnames(resid)) %>%
                    group_by(module) %>%
                    nest(.key = genes)


```

Lets get eigengene for each module
```{r}
MEs = as.tibble(net$MEs);
MEs$sample = rownames(resid)
MEs = MEs %>%
  gather(key = module_label, value = sample_loading, -sample) %>%
  group_by(module_label) %>%
  nest(.key = eigengene) %>%
  mutate(module = gsub('ME','',module_label))

modules = modules %>%
            left_join(MEs)

rm(MEs)
```
Lets get go enrichment for each module
```{r}
GOenr = GOenrichmentAnalysis(moduleLabels, yeastORFs = colnames(resid), organism = 'yeast')
tab = GOenr$bestPTerms[[4]]$enrichment %>%
            group_by(module) %>%
            nest(.key = 'go_data')


modules = modules %>%
            left_join(tab)
rm(tab)
```

Now lets export the modules for meme analyisis

```{r}
cluster_dir = '../../intermediate/clusters/WGCNA'
output_dir = paste0(cluster_dir, '/gene_lists')
dir.create(output_dir, recursive = TRUE)

library(readr)

write_genes = function(df, output_dir){
  write(df$name,
        file = paste0(output_dir,
                      '/cluster_',
                      unique(df$module),
                      '.txt')
        )
}

modules %>%
  dplyr::select(module, genes) %>% unnest() %>%
  split(.$module) -> by_module

lapply(by_module, function(x) write_genes(x, output_dir))

```


  Run MEME

```{bash}
bash src/scripts/meme/run_all.sh intermediate/clusters/WGCNA/gene_lists intermediate/clusters/WGCNA

```





  # After meme is run:
```{r}

tfs = do.call(rbind,
lapply(dir(paste0(cluster_dir, '/tfs/')),
function(x) {
  path = paste0(cluster_dir, '/tfs/', x)
  if(file.size(path) > 0) {
    return(data.frame(file = x,
                      TF = read.table(path, stringsAsFactors = F))
           )
  }
})) %>% as_tibble %>% separate(file, c('c', 'module', 't'), sep = '_') %>% dplyr::rename(TF = V1) %>% dplyr::select(module, TF) %>% group_by(module) %>% nest(.key = TFs)

modules = modules %>%
  left_join(tfs)

rm(tfs)

```



```{r data_saving}
save(list = c('std_resid_matrix',
              'std_residuals',
              'genes',
              'meta',
              'modules',
              'sample_tsne',
              't2g'),
     file = '../../intermediate/images/paper_data.RData')
```

```{r relative_importance}
# library(relaimpo)
# getri = function(mod){
# r = calc.relimp(mod, type = c('last'))@last
# return(r)
# }
# lasts = do.call(rbind, lapply(models$Full_model, getri))
```
