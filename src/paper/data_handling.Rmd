---
title: "Data Processing"
output: html_notebook
---


This notebook takes us from the DESeq2 normalized data, to all the data that is used for plotting in the paper.

```{r data_loading}

rm(list=ls())

load('../../input/images/normalized_data.RData')

library(tidyr)
library(purrr)
library(dplyr)
library(broom)
library(tibble)
library(magrittr)

measurements = vlog %>%
  as.data.frame %>%
  rownames_to_column("Gene") %>%
  as_tibble %>%
  gather(Sample_Name, Expression, -Gene)

rm(vlog)

meta = as_tibble(meta)

colnames(t2g)[1] = 'Gene'
t2g = as_tibble(t2g)

# should be a left join on the meta subsetted
meta_sub = meta %>% select(Sample_Name, Condition, Strain, Strain_Code)

measurements = left_join(measurements, meta_sub)

# Remove known bad sample

measurements %<>% filter(Strain_Code != 'WT1' | Condition != 'Rapamycin')

```

Next lets calculate some base statistics and define outliers:

```{r call_outlier}

is_outlier <- function(v, coef=1.5){
  quantiles <- quantile(v,probs=c(0.25,0.75))
  IQR <- quantiles[2]-quantiles[1]
  res <- v < (quantiles[1]-coef*IQR)|v > (quantiles[2]+coef*IQR)
  return(res)
}


measurements = measurements %>% group_by(Gene, Condition) %>%
                mutate(is_condition_outlier = is_outlier(Expression),
                       condition_outlier = ifelse(is_condition_outlier,
                                                  as.character(Strain),
                                                  NA)) %>%
                ungroup() %>%
              group_by(Gene, Strain) %>%
                mutate(is_strain_outlier = is_outlier(Expression),
                       strain_outlier = ifelse(is_strain_outlier,
                                               as.character(Condition),
                                               NA)) %>%
                ungroup()
```

```{r gene_statistics}
genes = measurements %>%
  group_by(Gene) %>%
  mutate(Differential_Expression = Expression - mean(Expression),
         Norm_Differential_Expression = Differential_Expression / sd(Expression)) %>%
  nest() %>%
  mutate(Gene_range = map_dbl(data, ~ diff(range(.$Expression))),
         Gene_sd = map_dbl(data, ~ sd(.$Expression)),
         Gene_mean = map_dbl(data, ~ mean(.$Expression))) %>%
  left_join(t2g)


```

create the linear model and extract model data:

```{r create_linear_models}
# Dont care about any other kinds of models anymore. base is just the mean which I can get easily.

# lin_mod = function(formula) {
#   function(data, ...){
#     map(data, ~ lm(formula, data = .))
#   }
# }
#
# list_model <- list(#Strain_model = Expression ~ Strain,
#                    #Condition_model = Expression ~ Condition,
#                    Full_model = Expression ~ Strain + Condition,
#                    Base_model = Expression ~ 1) %>%
#   lapply(lin_mod)
#
#
# models = genes %>%
#   mutate_at(.vars=("data"),.funs=list_model)

genes %<>%
  mutate(model = map(data, ~lm(Expression ~ Strain + Condition, data = .))) %>%
  mutate_at(.vars = vars(model),
            .funs = funs(performance = map(.,glance),
                         weights = map(.,tidy),
                         data_augment = map(.,augment)))

```

lets look at model performance, and figure out where our model breaks:

```{r}
genes %>% select(Gene_mean, performance) %>% unnest() %>% ggplot(aes(x=Gene_mean, y = r.squared)) + geom_point() + geom_vline(xintercept = 5.5)
```

It seems $R^2$ looks pretty bad when gene mean is below 5.5, probably becuase these genes are dominated by noise. lets therefore filter them out:

```{r gene_filter}
genes %<>%
  filter(Gene_mean > 5.5) # used to be mean > 6 to get all the good linear models. 3.6 seems good when looking at sd vs mean
```



Next lets do some basic clustering on the Differential Expression:

```{r tsne_cluster}
library(tsne)

do_tsne = function(mat){

  mat_meta = tibble(sample = colnames(mat)) %>%
    separate(sample, c('Condition', 'Strain_Code'), "_", remove = FALSE)

  pca = prcomp(t(mat))
  pca = data.frame(pca$x, sample = rownames(pca$x))
  meta_pc = full_join(mat_meta, pca)
  t = tsne(meta_pc %>% select(starts_with('PC')))
  colnames(t) = c('TSNE1', 'TSNE2')
  meta_pc = cbind(meta_pc, t)
  return(meta_pc)
}

gene_matrix = genes %>% unnest(data) %>%
  select(Gene, Condition, Strain_Code, Differential_Expression) %>%
  unite(sample, c(Condition, Strain_Code), remove = TRUE) %>%
  #group_by(Gene, sample) %>%
  #summarise(Differential_Expression = mean(Differential_Expression)) %>% # median would be better
  ungroup() %>%
  spread(sample, Differential_Expression)

sample_tsne = do_tsne(gene_matrix %>% select(-Gene))

```



Now lets extract the residuals for each model into it's own wide matrix

```{r extract_residuals}
std_residuals = genes %>%
  select(data, data_augment, name) %>%
  unnest() %>%
  select(name, Condition, Strain_Code, .std.resid) %>%
  unite(sample_id, c(Strain_Code, Condition)) %>%
  rename(residual = .std.resid)

full_std_resid_matrix = std_residuals %>%
  spread(key = sample_id,
         value=residual,
         drop = TRUE) %>%
  remove_rownames() %>%
  column_to_rownames(var = 'name') %>%
  as.matrix()


```

Lets sort the genes into clusters by clustering on significantly large residuals: TODO decide if we should also include the weights as additional columns to cluster on?
```{r}
resid = t(full_std_resid_matrix)
datTraits = tibble(Experiment = rownames(resid)) %>% separate(Experiment, c('Strain_Code', 'Condition'), '_', remove = F)
resid[abs(resid)<2] = 0
datExpr0 = resid

sampleTree = hclust(dist(datExpr0), method = "average");
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)

#datExpr0 = resid
cutoff_height = 160
abline(h = cutoff_height, col = "red");

clust = cutreeStatic(sampleTree, cutHeight = cutoff_height, minSize = 10)

keepSamples = (clust==1)
datExpr = datExpr0[keepSamples, ]
datTraits = datTraits[keepSamples, ]
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)


sampleTree = hclust(dist(datExpr), method = "average");
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to check no outliers", sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)


collectGarbage()

enableWGCNAThreads()




network_type = 'signed'


powers = c(1:40)

sft = pickSoftThreshold(datExpr,
                        powerVector = powers,
                        verbose = 5,
                        # corFnc = bicor,
                        # corOptions = list(maxPOutliers = 0.05),
                        networkType = network_type)

sft_table = sft$fitIndices

plot(sft_table$median.k.,
     -sign(sft_table$slope) * sft_table$SFT.R.sq,
     xlab="Soft Threshold (power)",
     ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft_table$median.k.,
     -sign(sft_table$slope) * sft_table$SFT.R.sq,
     labels=powers,
     col="red");


# should be 6, but i like 8

#sft$powerEstimate = 6

net = blockwiseModules(datExpr,
                       power = sft$powerEstimate,
                       networType = network_type,
                       # corType = 'bicor',
                       # corOptions = list(maxPOutliers = 0.05),
                       minModuleSize = 4,
                       deepSplit = 2, # 4 is very strong, 2 gets the job done. not sure about 3
                       maxBlockSize = 30000,
                       numericLabels = TRUE,
                       pamRespectsDendro = FALSE,
                       #saveTOMs = TRUE,
                       #saveTOMFileBase = "kinaseTOM",
                       verbose = 3)

moduleLabels = net$colors
moduleColors = labels2colors(moduleLabels)

#table(moduleColors)
#length(table(moduleColors))

# [rm(list=setdiff(ls(), c("datExpr", "sft", "network_type", "t2g", "expr", "full_std_resid_matrix", "datTraits", "resid")))

modules = tibble(module = as.character(moduleLabels),
                 name = colnames(datExpr)) %>% group_by(module) %>% left_join(genes) %>% nest(.key = 'gene_data')



```


```{r}


MEs = net$MEs;


GOenr = GOenrichmentAnalysis(moduleLabels, yeastORFs = colnames(datExpr), organism = 'yeast')
tab = GOenr$bestPTerms[[4]]$enrichment %>% group_by(module) %>% nest(.key = 'go_data')

modules %<>% left_join(tab)
#all = modules %>% group_by(module) %>% nest(.key = gene_info) %>% full_join(tab %>% group_by(module) %>% nest(.key = go_info))

```

Now lets export the modules for meme analyisis

```{r}


dir.create('WGCNA_modules')

library(readr)

write_genes = function(names, path){
  write(names$name, file=path)
}

modules %>%
  map(write_genes(.x$gene_data,
                  path = paste0('WGCNA_modules/cluster_',
                                as.character(unique(.$module)),
                                '_genes.txt')))


tab %>%
  group_by(module) %>%
  do(write_csv(., path = paste0('WGCNA_modules/cluster_',
                                as.character(unique(.$module)),
                                '_go_terms.csv')))


# After meme is run:

tfs = do.call(rbind,
lapply(dir('WGCNA_modules/tfs/'),
function(x) {
if(file.size(paste0('WGCNA_modules/tfs/', x)) > 0) {
return(data.frame(file = x, TF = read.table(paste0('WGCNA_modules/tfs/',x), stringsAsFactors = F)))
}})) %>% as_tibble %>% separate(file, c('c', 'module', 't'), sep = '_') %>% dplyr::rename(TF = V1) %>% dplyr::select(module, TF)



```



```{r data_saving}
save.image('../../input/images/paper_data.RData')
```

```{r relative_importance}
library(relaimpo)
getri = function(mod){
r = calc.relimp(mod, type = c('last'))@last
return(r)
}
lasts = do.call(rbind, lapply(models$Full_model, getri))
```
