## Discrepancies in the linear model predict epistatic relationships


```{r, message=FALSE, warning=FALSE}
library(plotly)
```

### Calculation of standard residuals

We will calculate the standardized residuals for each measurement, where standardized residuals are defined as

$$ S_g = \frac{E_g - \hat{E_g}}{\overline{E_g}} $$

```{r ref.label='extract_residuals', eval = FALSE}
```

Now that we have the standardized residuals, lets take a look at them. What structure do they have? lets take a deep dive.

First question, what is the spread of these standardized residuals, according to theory, they should look similar to a z-score, meaning that they are normally distributed. lets check:

```{r}
resids = std_residuals %>% filter(residual_type == 'Full') %>% pull(residual) 
hist(resids, breaks = 200)
```

Okay, that looks good, but what are the mean and variance? we expect 0, and 1.

```{r}
print(paste('Mean:', mean(resids)))
print(paste('Standard Deviation:', sd(resids)))

```

Close enough!

### Using residual size to predict epistasis

We extract measurements that have the largetst residuals, and look at the experimental conditions that produced them. lets take a look at the top ones:

```{r, warning=FALSE, message=FALSE}
std_residuals %>%
  filter(residual_type == 'Full') %>% 
  arrange(-abs(residual)) %>% 
  select(-residual_type) %>% 
  left_join(t2g %>% select(Gene, name, description)) %>%
  separate(sample_id,c('Condition','Strain'), sep='_') -> hypotheses

knitr::kable(hypotheses[1:15,], caption = 'The most significant residuals')
```

This table is availble as a supplemental table saved here:

```{r}
write.csv(hypotheses, file = 'hypotheses.csv')
```

Next, lets see what `Condition + Strain` pairs contain significant residuals over all genes in the ESR:

```{r}
hypotheses %>% 
  filter(abs(residual) > 3) %>% 
  filter(Gene %in% c(scan('../../input/genes_of_interest_and_gene_sets/ESR/repressed_ESR.txt', what = character()),
                     scan('../../input/genes_of_interest_and_gene_sets/ESR/activated_ESR.txt', what = character()))) %>%
  select(Condition, Strain) %>% 
  table() %>%
  `+`(1) %>%
  log() %>%
  heatmap(col=viridis::viridis(20))

```

#### Some quick observations here:
* Kinases in the same pathway cluster together:
    + SLT2 and PKC are very closly clustered!
    + PBS2 and HOG1 are very closly clutered!
* SCH9 Seems to have an effect, but only in YPD?

#### Diving into a some examples

Okay, so if the findings above are true, we should see that the residuals between PBS2, and HOG1 to corrolate for genes that have significant residuals. lets check that now:

```{r, warning=FALSE}
p = hypotheses %>% 
    filter(abs(residual) > 3) %>% 
    filter(Strain %in% c('HOG1', 'PBS2')) %>% 
  select(name, residual, Strain, Condition) %>% 
  spread(Strain, residual) %>% 
  mutate_at(3:4, function(x) if_else(is.na(x),0,x)) %>% 
  ggplot(aes(x=HOG1,y=PBS2,fill=Condition,color = Condition, text= paste(name, Condition, sep='_'))) + geom_point() 
plotly::ggplotly(p, width = 880)
```

Interestingly, inactivation of PBS2, and HOG1 do not always produce the correlated residuals. They do for Salt, but do not for Menadione, and Glucose Dropout. This might be evidence that PBS2 and HOG1 have different functions in non-salt conditions. 

I dont know much about SLT2, and PCK1, other than they are in the same pathway. Lets take a look at them. (residual cutoff at 2)

```{r, warning=FALSE}
p = hypotheses %>% 
  filter(abs(residual) > 2) %>% 
  filter(Strain %in% c('SLT2', 'PKC1')) %>% 
  select(name, residual, Strain, Condition) %>% 
  spread(Strain, residual) %>% 
  mutate_at(3:4, function(x) if_else(is.na(x),0,x)) %>% 
  ggplot(aes(x=SLT2,y=PKC1,fill=Condition, text= paste(name, Condition, sep='_'))) + geom_point() 
plotly::ggplotly(p, width = 880)
```

#### Expanding single gene analysis to gene modules

Here we build up residual paturns from a single gene to a module.

As an example, we are going to look into the mating pathway. The mating pathway shares a kinase with the HOG pathway (STE11). It is known that mating pathway genes are not expressed during salt stress, and that their repression is due to the activity of the HOG pathway.

We see this phenominon in our data:


```{r}
hypotheses %>% 
  filter(name == 'FUS1') %>% 
  select(Strain, Condition, residual) %>% 
  group_by(Strain, Condition) %>% 
  summarise_all(mean) %>% 
  ggplot(aes(x = Strain, y= Condition, fill = residual)) + geom_tile() + scale_fill_gradient2(low = ('cyan'), mid = 'black', high = 'yellow') + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ggtitle('FUS1')

hypotheses %>% 
  filter(name == 'AGA1') %>% 
  select(Strain, Condition, residual) %>% 
  group_by(Strain, Condition) %>% 
  summarise_all(mean) %>% 
  ggplot(aes(x = Strain, y= Condition, fill = residual)) + geom_tile() + scale_fill_gradient2(low = ('cyan'), mid = 'black', high = 'yellow') + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ggtitle('AGA1')

```


Although we do not have replicates of these residuals, we can become more confident in our prediciton if we see a similar patturn in the whole mating pathway. 

To define a pathway, we use INSPIRE to cluster genes using other datatsets.

These clusters were actually generated from orthogonal data (gasch, and pronk datasets)
NB: for this data I actually also include my data... need to fix

I happen to know that FUS1 cluster is cluster 36 in this dataset, which I hope will exhibit the same residual patturn (activated in Salt, when PBS2, or HOG1 are inactive)

```{r}
clusters_inspire = read.csv('../../input/clusters/INSPIRE_clusters/all_clusters.csv')
want = clusters_inspire %>% filter(Cluster==36) %>% select(Gene)
hypotheses %>% 
  filter(Gene %in% want$Gene) %>% 
  select(Strain, Condition, residual) %>% 
  group_by(Strain, Condition) %>% 
  summarise_all(mean) %>% 
  ggplot(aes(x = Strain, y= Condition, fill = residual)) + geom_tile() + scale_fill_gradient2(low = ('cyan'), mid = 'black', high = 'yellow') + theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

And it does. Although we do not have repliactes for FUS1, if we average the residuals for the __module__ where FUS1 was included we get a robust residual patturn.


Lets see if there are meaningful go terms and motifs for this cluster:

```{r}
#knitr::kable(this_cluster)
webshot::webshot("../../intermediate/INSPIRE_clusters/cluster_36/ame.html")
```

And what about GO terms?

```{r, warning=FALSE, message=FALSE}
get_go_terms_from_list = function(query_list, background_list) {
    library(goseq)
    library(org.Sc.sgd.db)
    genes = numeric(length(background_list))
    names(genes) = background_list
    genes[query_list] = 1
    pwf = nullp(genes,"sacCer2","ensGene")
    GO.wall=goseq(pwf,gene2cat=as.list(org.Sc.sgdGO2ALLORFS))
    return(GO.wall)
}

print_out_terms = function(g_dir){
  library(knitr)
  g_dir %>%
    dplyr::mutate(pval = min(over_represented_pvalue, under_represented_pvalue),
                  percent_in = numDEInCat / numInCat) %>%
    dplyr::arrange(pval) %>%
    dplyr::filter(pval<0.001) %>% 
    dplyr::select(term, pval, percent_in) %>% 
    arrange(-percent_in, pval) %>%
    head() %>% kable()
}

g = get_go_terms_from_list(clusters_inspire %>% filter(Cluster == 36) %>% pull(Gene),
                       t2g$Gene)
print_out_terms(g)
```



<!-- ### Error modules (groups of error profiles) reveal Known classes of epistatic relationships -->
<!-- <!-- Class 1 --> -->
<!-- The linear model assumes that Kinase identity and Condition identity make independent contributions to gene expression.   -->

<!-- 1. If a Condition's effect propagates through a inhibition given Kinase, then the linear model will overestimate gene expression for that Condition-Kinase pair   -->
<!--     * HSP12 on Salt + PKA (Get GD?) -->
<!-- 2. If a Kinase's activity is required to correctly regulate a gene's expression in a condition specific manner, the linear model will badly estimate that condition specific interaction (as there is no term to correct for such a fine tuned response) -->
<!-- 	  * Mating pathway   -->

