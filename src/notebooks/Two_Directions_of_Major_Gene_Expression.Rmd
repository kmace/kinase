---
title: "Global Analysis of Kinase Drivers of the Yeast Stress Response"
output:
  html_document: default
  html_notebook: default
  pdf_document: default
---

```{r,message=FALSE, echo=FALSE}
source('../utils/load_libraries.R')
```

```{r, message=FALSE, echo=FALSE, cache=FALSE}
source('../utils/load_functions.R')
source('../utils/load_data.R')
```
# Setup
We will be condsidering the samples that have been inhibited:
```{r}
# Filter
vsd = vsd[,colData(vsd)$Drug == 'Cocktail']
meta = colData(vsd)
meta = as.data.frame(meta)
meta = meta %>% mutate(Condition = if_else(Stress=='None',
                                           as.character(Media),
                                           as.character(Stress)
                                          ))
meta$Condition = as.factor(meta$Condition)
x = assay(vsd)
x = x - rowMeans(x)
colnames(x) = meta$Sample_Name

gasch = load_gasch()
gx = gasch$data
gmeta = gasch$meta

pronk = load_pronk()
px = pronk$data
pmeta = pronk$meta

common_genes = Reduce(intersect, 
                      list(rownames(gx), 
                           rownames(x), 
                           rownames(px)))

x = x[common_genes, ]
gx = gx[common_genes, ]
px = px[common_genes, ]
```
# Overview
##Prinicipal Component Decomposition
```{r}
pca = prcomp(t(x))
meta_pc = cbind(as.data.frame(meta),
                as.data.frame(
                  pca$x[match(meta$Sample_Name,rownames(pca$x)),]
                  ))
```
First, let look at how much variance is explained by each PC:
```{r}
barplot(summary(pca)$importance[2,1:10],
     main='Percentage of Variance Explained',
     xlab='PCs',
     ylab='Percentage of Variance Explained',
     ylim=c(0,1))
100 * summary(pca)$importance[2,1:9]
```
PC1 with 35%, PC2 with 20%, and the next PCs - 3 & 4 are down to ~7% of the variance.

Let's now look at how the first two Principal Component separate the samples:
```{r}
plot = ggplot(meta_pc, aes(x=PC1, y=PC2)) +
       geom_point(shape = 21, aes(fill = Condition), size=4, stroke=1) +
       geom_text(aes(label=Strain), size=1)

ggplotly(plot)
```
## Sample Extreams
The above plot has a intersting shape, a triangle with 3 conditions strongly defining the corners:
```{r}
plot = ggplot(meta_pc %>% filter(Condition %in% c('YPD','Glucose Depletion', 'Rapamycin')), aes(x=PC1, y=PC2)) +
       geom_point(shape = 21, aes(fill = Condition), size=4, stroke=1) +
       geom_text(aes(label=Strain), size=1) +
       scale_fill_discrete(drop = FALSE)

ggplotly(plot)
```
The conditions that make up the vertices of the triangle are:
* No Stress
* Glucose Dropout
* Rapamycin

These 3 are particularly intersting:
* No Stress could be considered an origin
* Rapamycin is the canonical activator of the TOR pathway
* Glucose Depletion is the cononical activators of the PKA pathway

#Hypothesis
## Statement
One potential hypothesis is therefore:

1. The direction of the two vertices away from the control indicate the pathway activity for PKA and TOR.
  + I will refer to these directions as the PKA and TOR __cardinal__ directions
2. As far as PKA and TOR go, every stress I tested is some linear combination of PKA and TOR, which could be used to create a hierachy of stresses

## Possible Evidence
If this hypothesis is true, I would expect the following:
1. Within each individual condition, activation of PKA and TOR2 pathways should move the sample in their respective __cardinal__ direction. 
2. If I project other stress datasets onto these prinicpal components, I should see a similar pattern.
3. If I look at the gene loadings of these cardinal directions, I should extract genes associated with PKA and TOR.

# Results
## Cardinality
```{r}
  for(s in levels(meta$Condition)) {
  plot = ggplot(meta_pc, aes(x=PC1, y=PC2)) +
         geom_point(data = subset(meta_pc, Condition == s),
                    aes(fill = Condition,
                    size = if_else(Strain %in% c('TPK123','TOR2'),4,2),
                    color = if_else(Strain %in% c('TPK123','TOR2'),2,1)),
                    shape = 21,
                    stroke=1) +
         geom_text(aes(label=Strain),
                   size=1) +
         scale_fill_discrete(drop = FALSE) +
         labs(title = s) +
         guides(size=FALSE, color=FALSE) +
         scale_size(range = c(3, 7))
  print(plot)
  }

```
<!-- If you want to use facet_wrap 
```{r, fig.height=14, fig.width=7}

  plot = ggplot(meta_pc, aes(x=PC1, y=PC2)) +
         geom_point(aes(fill = Condition,
                    size = if_else(Strain %in% c('TPK123','TOR2'),4,2),
                    color = if_else(Strain %in% c('TPK123','TOR2'),2,1)),
                    shape = 21,
                    stroke=1) +
         geom_text(aes(label=Strain),
                   size=1) +
         scale_fill_discrete(drop = FALSE) +
         guides(size=FALSE, color=FALSE) +
         scale_size(range = c(3, 7)) +
         facet_wrap(~Condition, scales = 'fixed', ncol = 2)
  print(plot)


```
-->

## Projection of other data
### Gasch
```{r}
g_on_x = predict(pca,t(gx))
gmeta_on_x = cbind(gmeta, g_on_x)

plot = ggplot(gmeta_on_x, 
              aes(x=PC1,
                  y=PC2,
                  label = ifelse(is.na(Time), "", sprintf("%1.0f",Time)),
                  fill = Stress_after)) + 
       geom_point(shape = 21, size=4, stroke=1) +
       geom_text(na.rm = FALSE, size=1.5)
ggplotly(plot, tooltip = c("y", "x", "Time", 'fill'))
# # This is to look at the PCs of the actual datset:
# gpca = prcomp(t(gx))
# gmeta_pc = cbind(as.data.frame(gmeta),
#                 as.data.frame(
#                   gpca$x[match(gmeta$Sample_Name,rownames(gpca$x)),]
#                   ))
# plot = ggplot(gmeta_pc, aes(x=PC1, y=PC2)) + geom_point(shape = 21, size=4, stroke=1)
# print(plot)

# # To include time:
# plot = ggplot(gmeta_pc, aes(x=PC1, y=PC2)) +
#        geom_point(shape = 21, 
#                   aes(fill = Stress_after), 
#                   size=4, 
#                   stroke=1) + 
#        geom_text(aes(label = ifelse(is.na(Time), "", sprintf("%1.0f",Time))), 
#                  na.rm = FALSE, 
#                  size=2)
```
### Pronk

```{r}
p_on_x = predict(pca,t(px))
pmeta_on_x = cbind(pmeta, p_on_x)

plot = ggplot(pmeta_on_x, 
              aes(x=PC1,
                  y=PC2,
                  fill = Condition)) + # TODO Add color when you have meta 
       geom_point(shape = 21, size=4, stroke=1) #+
       #geom_text(na.rm = FALSE, size=1.5)
ggplotly(plot)#, tooltip = c("y", "x", "Time", 'fill'))

# # This is to look at the PCs of the actual datset:
# ppca = prcomp(t(px))
# pmeta_pc = cbind(as.data.frame(pmeta),
#                 as.data.frame(
#                   ppca$x[match(pmeta$title,rownames(ppca$x)),]
#                   ))
# plot = ggplot(pmeta_pc, aes(x=PC1, y=PC2)) + geom_point(shape = 21, size=4, stroke=1)
# print(plot)
```









<!-- what about the guys who arent more than 10 hours long?

```{r, fig.width=10}
gasch = read.table('../../input/reference/gasch/pickGenes/imputed_gasch_data.txt', header=T, row.names = 1)
gmeta = read.csv('../../input/meta/gasch_meta.csv')
Stress_after = as.character(gmeta$Stress)
Stress_after[gmeta$Time<10] = 'Pre-response'
gmeta$Stress_after = factor(Stress_after)

really_long = which(gmeta$Time >= 600)
gasch = gasch[ ,-really_long]
gmeta = gmeta[-really_long, ]
gx = gasch
rv = genefilter::rowVars(gx)
select = order(rv, decreasing = TRUE)[seq_len(4000)]
gx = gx[select, ]
colnames(gx) = gmeta$Sample_Name
gpca = prcomp(t(gx))
gmeta_pc = cbind(as.data.frame(gmeta),
                as.data.frame(
                  pca$x[match(gmeta$Sample_Name,rownames(pca$x)),]
                  ))

p1 = ggplot(gmeta_pc, aes(x=PC1,
                         y=-PC6,
                         label = ifelse(is.na(Time), "", sprintf("%1.0f",Time)),
                         fill = Stress_after)) + geom_point(shape = 21, size=4, stroke=1) + geom_text(na.rm = FALSE, size=1.5)
# You can click the circles to make them go away!
ggplotly(p1, tooltip = c("y", "x", "Time", 'fill'))
```
 -->

Can we compare the PCs of each dataset?

```{r}
pca = prcomp(t(x))
gpca = prcomp(t(gx))
ppca = prcomp(t(px))

gsim = cor(pca$rotation, gpca$rotation)
psim = cor(pca$rotation, ppca$rotation)

get_best_pc = function(source_pc, target_pc, num_target, num_best_source){
  sim = cor(source_pc$rotation, target_pc$rotation)
  abs_sim = abs(sim)
  care = abs_sim[,1:num_target]
  source_pc_names = rownames(care)
  best = apply(care,2,function(x) source_pc_names[order(x,decreasing = T)[1:num_best_source]])
  return(best)
}
#get_best_pc(pca,pca,10,5)
```
What are the best PCs from my data to match Gasch PCs?
```{r}
get_best_pc(pca,gpca,10,3)
```
What are the best PCs from my data to match Pronk PCs?
```{r}
get_best_pc(pca,ppca,10,3)
```


```
